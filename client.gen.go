// Package main provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Assets defines model for assets.
type Assets struct {
	// AssetID Asset data, see schema for `asset`.
	AssetID *map[string]interface{} `json:"assetID,omitempty"`
}

// Author defines model for author.
type Author struct {
	// Donate Donation info of this author. May be a link to a donation page, or an email prefixed with `paypal:` to indicate a PayPal address.
	Donate *string `json:"donate"`

	// Email Email address of the author.
	Email *string `json:"email"`

	// Link The author's preferred link to their portfolio.
	Link *string `json:"link"`

	// Name The author's full name, which may be different from the ID.
	Name *string `json:"name,omitempty"`
}

// File defines model for file.
type File struct {
	// Md5 MD5 checksum for verifying file integrity.
	Md5 *string `json:"md5,omitempty"`

	// Size Size of the file in bytes.
	Size *int `json:"size,omitempty"`

	// Url Direct URL to download this file.
	Url *string `json:"url,omitempty"`
}

// FileWithIncludes defines model for fileWithIncludes.
type FileWithIncludes struct {
	// Include A list of files that this file depends on and should be included when downloaded, typically textures that the model/texture uses.
	Include *struct {
		Path *File `json:"$path,omitempty"`
	} `json:"include,omitempty"`

	// Md5 MD5 checksum for verifying file integrity.
	Md5 *string `json:"md5,omitempty"`

	// Size Size of the file in bytes.
	Size *int `json:"size,omitempty"`

	// Url Direct URL to download this file.
	Url *string `json:"url,omitempty"`
}

// Hdri HDRI data, extends `asset` schema.
type Hdri struct {
	// Authors Who created this asset, and what they did.
	Authors *struct {
		// AuthorID Credit
		AuthorID *string `json:"$authorID,omitempty"`
	} `json:"authors,omitempty"`

	// Backplates Whether there are backplates available for this HDRI.
	Backplates *bool `json:"backplates"`

	// Categories A string array of categories that this asset belongs to.
	Categories *[]interface{} `json:"categories,omitempty"`

	// Coords Decimal lat/lon GPS coordinates.
	Coords *[]interface{} `json:"coords"`

	// DatePublished The epoch timestamp in seconds of when this asset was published.
	DatePublished *int `json:"date_published,omitempty"`

	// DateTaken Legacy (untrustworthy) epoch timestamp of when this HDRI was taken. Timezone issues caused this data to be generally unused and inaccurate. May be solved in future but don't depend on it!
	// Deprecated:
	DateTaken *int `json:"date_taken,omitempty"`

	// Donated Whether or not this asset was donated free of charge to us.
	Donated *bool `json:"donated"`

	// DownloadCount The number of times this asset was downloaded. Useful for sorting by popularity.
	DownloadCount *int `json:"download_count,omitempty"`

	// EvsCap The number of exposure brackets captured when shooting this HDRI. I.e. the difference between the brightest and darkest shots, an indication of dynamic range.
	EvsCap *int `json:"evs_cap,omitempty"`

	// FilesHash A SHA1 hash of the files object (from the /files endpoint), which will change whenever the files are updated.
	FilesHash *string `json:"files_hash,omitempty"`

	// Name The human-readable/display name.
	Name *string `json:"name,omitempty"`

	// Tags A string array of tags for this asset to help with search matches.
	Tags *[]interface{} `json:"tags,omitempty"`

	// ThumbnailUrl The URL of the preview image thumbnail for this asset. Provided in .webp format.
	ThumbnailUrl *string `json:"thumbnail_url,omitempty"`

	// Type The asset type, for HDRIs this is 0.
	Type *int `json:"type,omitempty"`

	// Whitebalance The whitebalance in Kelvin that this HDRI and any included backplates were shot at. May not be present for all assets.
	Whitebalance *int `json:"whitebalance"`
}

// HdriFiles defines model for hdriFiles.
type HdriFiles struct {
	Backplates *struct {
		Image *struct {
			Format *File `json:"$format,omitempty"`
		} `json:"$image,omitempty"`
	} `json:"backplates"`
	Colorchart *OptionalFile `json:"colorchart,omitempty"`
	Hdri       *struct {
		Resolution *struct {
			Format *File `json:"$format,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"hdri,omitempty"`
	Tonemapped *OptionalFile `json:"tonemapped,omitempty"`
}

// Model Model data, extends `asset` schema.
type Model struct {
	// Authors Who created this asset, and what they did.
	Authors *struct {
		// AuthorID Credit
		AuthorID *string `json:"$authorID,omitempty"`
	} `json:"authors,omitempty"`

	// Categories A string array of categories that this asset belongs to.
	Categories *[]interface{} `json:"categories,omitempty"`

	// DatePublished The epoch timestamp in seconds of when this asset was published.
	DatePublished *int `json:"date_published,omitempty"`

	// Donated Whether or not this asset was donated free of charge to us.
	Donated *bool `json:"donated"`

	// DownloadCount The number of times this asset was downloaded. Useful for sorting by popularity.
	DownloadCount *int `json:"download_count,omitempty"`

	// FilesHash A SHA1 hash of the files object (from the /files endpoint), which will change whenever the files are updated.
	FilesHash *string `json:"files_hash,omitempty"`

	// Name The human-readable/display name.
	Name *string `json:"name,omitempty"`

	// Tags A string array of tags for this asset to help with search matches.
	Tags *[]interface{} `json:"tags,omitempty"`

	// ThumbnailUrl The URL of the preview image thumbnail for this asset. Provided in .webp format.
	ThumbnailUrl *string `json:"thumbnail_url,omitempty"`

	// Type The asset type, for models this is 2.
	Type *int `json:"type,omitempty"`
}

// ModelFiles defines model for modelFiles.
type ModelFiles struct {
	Map *struct {
		Resolution *struct {
			Format *File `json:"$format,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"$map,omitempty"`
	Blend *struct {
		Resolution *struct {
			Blend *FileWithIncludes `json:"blend,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"blend,omitempty"`
	Fbx *struct {
		Resolution *struct {
			Fbx *FileWithIncludes `json:"fbx,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"fbx,omitempty"`
	Gltf *struct {
		Resolution *struct {
			Gltf *FileWithIncludes `json:"gltf,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"gltf,omitempty"`
	Usd *struct {
		Resolution *struct {
			Usd *FileWithIncludes `json:"usd,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"usd,omitempty"`
}

// OptionalFile defines model for optionalFile.
type OptionalFile struct {
	// Md5 MD5 checksum for verifying file integrity.
	Md5 *string `json:"md5,omitempty"`

	// Size Size of the file in bytes.
	Size *int `json:"size,omitempty"`

	// Url Direct URL to download this file.
	Url *string `json:"url,omitempty"`
}

// Texture Texture data, extends `asset` schema.
type Texture struct {
	// Authors Who created this asset, and what they did.
	Authors *struct {
		// AuthorID Credit
		AuthorID *string `json:"$authorID,omitempty"`
	} `json:"authors,omitempty"`

	// Categories A string array of categories that this asset belongs to.
	Categories *[]interface{} `json:"categories,omitempty"`

	// DatePublished The epoch timestamp in seconds of when this asset was published.
	DatePublished *int `json:"date_published,omitempty"`

	// Dimensions An array with the dimensions of this asset on each axis in millimeters.
	Dimensions *[]interface{} `json:"dimensions,omitempty"`

	// Donated Whether or not this asset was donated free of charge to us.
	Donated *bool `json:"donated"`

	// DownloadCount The number of times this asset was downloaded. Useful for sorting by popularity.
	DownloadCount *int `json:"download_count,omitempty"`

	// FilesHash A SHA1 hash of the files object (from the /files endpoint), which will change whenever the files are updated.
	FilesHash *string `json:"files_hash,omitempty"`

	// Name The human-readable/display name.
	Name *string `json:"name,omitempty"`

	// Tags A string array of tags for this asset to help with search matches.
	Tags *[]interface{} `json:"tags,omitempty"`

	// ThumbnailUrl The URL of the preview image thumbnail for this asset. Provided in .webp format.
	ThumbnailUrl *string `json:"thumbnail_url,omitempty"`

	// Type The asset type, for textures this is 1.
	Type *int `json:"type,omitempty"`
}

// TextureFiles defines model for textureFiles.
type TextureFiles struct {
	Map *struct {
		Resolution *struct {
			Format *File `json:"$format,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"$map,omitempty"`
	Blend *struct {
		Resolution *struct {
			Blend *FileWithIncludes `json:"blend,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"blend,omitempty"`
	Gltf *struct {
		Resolution *struct {
			Gltf *FileWithIncludes `json:"gltf,omitempty"`
		} `json:"$resolution,omitempty"`
	} `json:"gltf,omitempty"`
}

// GetAssetsParams defines parameters for GetAssets.
type GetAssetsParams struct {
	// Type Filter to assets of a particular type. Can be `hdris`/`textures`/`models`/`all`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Categories A comma-separated list of categories to filter by. Only assets that match all categories specified will be included. Use the `/categories` endpoint to get a list of available categories.
	Categories *string `form:"categories,omitempty" json:"categories,omitempty"`
}

// GetCategoriesTypeParams defines parameters for GetCategoriesType.
type GetCategoriesTypeParams struct {
	// In A comma separated list of categories - only returns categories with assets that are also in these categories. The value of each key is then also only counting assets that are in both the categories specified and the key. If this is not specified, then an `all` "category" is also returned, with the count of all assets of the specified type.
	In *string `form:"in,omitempty" json:"in,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAssets request
	GetAssets(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorId request
	GetAuthorId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoriesType request
	GetCategoriesType(ctx context.Context, pType string, params *GetCategoriesTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilesId request
	GetFilesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfoId request
	GetInfoId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTypes request
	GetTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAssets(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoriesType(ctx context.Context, pType string, params *GetCategoriesTypeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesTypeRequest(c.Server, pType, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfoId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTypes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTypesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAssetsRequest generates requests for GetAssets
func NewGetAssetsRequest(server string, params *GetAssetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Categories != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "categories", runtime.ParamLocationQuery, *params.Categories); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorIdRequest generates requests for GetAuthorId
func NewGetAuthorIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesTypeRequest generates requests for GetCategoriesType
func NewGetCategoriesTypeRequest(server string, pType string, params *GetCategoriesTypeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "type", runtime.ParamLocationPath, pType)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.In != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "in", runtime.ParamLocationQuery, *params.In); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilesIdRequest generates requests for GetFilesId
func NewGetFilesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoIdRequest generates requests for GetInfoId
func NewGetInfoIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTypesRequest generates requests for GetTypes
func NewGetTypesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAssetsWithResponse request
	GetAssetsWithResponse(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*GetAssetsResponse, error)

	// GetAuthorIdWithResponse request
	GetAuthorIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAuthorIdResponse, error)

	// GetCategoriesTypeWithResponse request
	GetCategoriesTypeWithResponse(ctx context.Context, pType string, params *GetCategoriesTypeParams, reqEditors ...RequestEditorFn) (*GetCategoriesTypeResponse, error)

	// GetFilesIdWithResponse request
	GetFilesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFilesIdResponse, error)

	// GetInfoIdWithResponse request
	GetInfoIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInfoIdResponse, error)

	// GetTypesWithResponse request
	GetTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypesResponse, error)
}

type GetAssetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Assets
}

// Status returns HTTPResponse.Status
func (r GetAssetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Author
}

// Status returns HTTPResponse.Status
func (r GetAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesTypeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Category Count of assets in this category.
		Category *int `json:"$category,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCategoriesTypeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesTypeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r GetFilesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r GetInfoIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]interface{}
}

// Status returns HTTPResponse.Status
func (r GetTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAssetsWithResponse request returning *GetAssetsResponse
func (c *ClientWithResponses) GetAssetsWithResponse(ctx context.Context, params *GetAssetsParams, reqEditors ...RequestEditorFn) (*GetAssetsResponse, error) {
	rsp, err := c.GetAssets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetsResponse(rsp)
}

// GetAuthorIdWithResponse request returning *GetAuthorIdResponse
func (c *ClientWithResponses) GetAuthorIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAuthorIdResponse, error) {
	rsp, err := c.GetAuthorId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorIdResponse(rsp)
}

// GetCategoriesTypeWithResponse request returning *GetCategoriesTypeResponse
func (c *ClientWithResponses) GetCategoriesTypeWithResponse(ctx context.Context, pType string, params *GetCategoriesTypeParams, reqEditors ...RequestEditorFn) (*GetCategoriesTypeResponse, error) {
	rsp, err := c.GetCategoriesType(ctx, pType, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesTypeResponse(rsp)
}

// GetFilesIdWithResponse request returning *GetFilesIdResponse
func (c *ClientWithResponses) GetFilesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetFilesIdResponse, error) {
	rsp, err := c.GetFilesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilesIdResponse(rsp)
}

// GetInfoIdWithResponse request returning *GetInfoIdResponse
func (c *ClientWithResponses) GetInfoIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetInfoIdResponse, error) {
	rsp, err := c.GetInfoId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoIdResponse(rsp)
}

// GetTypesWithResponse request returning *GetTypesResponse
func (c *ClientWithResponses) GetTypesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTypesResponse, error) {
	rsp, err := c.GetTypes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTypesResponse(rsp)
}

// ParseGetAssetsResponse parses an HTTP response from a GetAssetsWithResponse call
func ParseGetAssetsResponse(rsp *http.Response) (*GetAssetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Assets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAuthorIdResponse parses an HTTP response from a GetAuthorIdWithResponse call
func ParseGetAuthorIdResponse(rsp *http.Response) (*GetAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Author
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCategoriesTypeResponse parses an HTTP response from a GetCategoriesTypeWithResponse call
func ParseGetCategoriesTypeResponse(rsp *http.Response) (*GetCategoriesTypeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesTypeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Category Count of assets in this category.
			Category *int `json:"$category,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFilesIdResponse parses an HTTP response from a GetFilesIdWithResponse call
func ParseGetFilesIdResponse(rsp *http.Response) (*GetFilesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetInfoIdResponse parses an HTTP response from a GetInfoIdWithResponse call
func ParseGetInfoIdResponse(rsp *http.Response) (*GetInfoIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTypesResponse parses an HTTP response from a GetTypesWithResponse call
func ParseGetTypesResponse(rsp *http.Response) (*GetTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
